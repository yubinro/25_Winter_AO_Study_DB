# 5주차 — 쿼리 성능과 서버 병목

**핵심 질문**

- 느린 건 서버야? DB야? ( DB 엔진은 ? )

**내용**

- Query 실행 흐름
- Index가 서버 성능에 미치는 영향
- N+1 문제
- ORM 이란 ?
- ORM이 DB를 망칠까 안망칠까

**키워드**

`Index`, `Execution Plan`, `ORM`

---

# 시스템 성능 문제의 두 가지 원인

## 응답 (Response)?

- 처리 하나당 소요되는 시간 → 검색 엔진에서 키워드를 입력하고 검색을 누른 후 검색 결과가 표시되기까지 걸리는 시간 = 응답 시간
- 응답 문제 : 각 서버 이상으로 인한 응답 시간 지연 → 로그 등을 보면 어느 정도 문제 파악 가능
    - 네트워크 문제 + 물리적인 한계(시스템에 도달까지의 경로 복잡)
        - 처리량 개선을 통해 시스템 전체 사용률을 개선하는 것이 일반적

## 처리량 (Throughput)?

- 단위 시간당 처리하는 양 → 검색 엔진이 초당 받아들이는 사용자 수
- 처리량 문제 : 대량의 데이터를 교환하는데 영역이 부족한 경우에 발생
    - 물리적으로 데이터를 통과시킬 수 없을 때 처리량 관점의 병목 현상 발생

→ 응답과 처리량은 밀접한 관계

- 응답이 매우 느린 시스템에서는 다수의 사용자 요청이 시스템 내에 누적되므로 전체 처리량 저하
- 처리량이 포화 상태가 되면 리소스가 부족해져서 응답도 함께 악화 → 병목 현상을 개선하려면 반드시 응답과 처리량 모두 고려하여 진행하여야 한다.

---

## 병목 현상

- 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상

![image.png](5%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%EC%BF%BC%EB%A6%AC%20%EC%84%B1%EB%8A%A5%EA%B3%BC%20%EC%84%9C%EB%B2%84%20%EB%B3%91%EB%AA%A9/image.png)

- 3 Tier 시스템에서 어플리케이션 서버의 CPU 사용률이 높아져 처리량 한계 도달
- →API 서버에 대한 응답 시간이 악화
- → API 서버 = 병목 지점

### 병목 지점은 반드시 존재한다.

→ 모든 서버, 소트프웨어, 물리 엔진이 균등하게 처리량을 분배하는 것은 이론상 불가능

→ 특정 부분의 처리량이 조금이라도 낮다면 그곳이 병목 지점

---

## DB 서버 병목 개선

→ 시스템 성능 저하가 발생했을 때 그 원인이 서버에 있는지 DB에 있는지 구분하는 것이 성능 개선의 첫 단계

- 서버 병목
    - 과도한 CPU 연산
    - 메모리 누수
    - 스레드 부족으로 인한 요청 비처리
    - 서버 리소스 부족
- DB 병목
    - 디스크 I/O(입출력) 속도 느림
    - 비효율적인 쿼리로 인한 데이터 처리 시간 증가
    - DB 사용 애플리케이션 문제

→ 대부분의 웹 서비스 지연은 DB 병목에서 발생한다.

---

## 쿼리 실행 흐름 (Query Execution Flow)

→ 클라이언트가 SQL을 요청했을 때 DB 내부에서 처리되는 과정

- 파서 (parser) : 클라이언트가 보낸 SQL 문법의 오류를 검사하고 처리 가능한 단위로 분해한다. = SQL 문법을 검사하고 쪼개는 역할
- 옵티마이저 (optimizer) : 데이터를 가장 빠르고 효율적으로 가져올 수 있는 경로(실행 계획)을 결정한다. = 최적의 실행 경로를 짜는 역할
- 익스큐터, 실행기 (executor) : optimizer가 결정한 계획에 따라 스토리지 엔진에 데이터를 요청한다. = 데이터를 실제로 가져오고 처리하는 역할
- 스토리지 엔진 (storage engine) : 디스크나 메모리에서 실제 데이터를 읽어온다.

---

## ORM 이란?

- 정의 : 객제지향프로그래밍 언어(자바,파이썬 등등)의 객체와 관계형 데이터베이스 (RDB)의 테이블을 자동으로 연결해주는 기술
- 역할 : 개발자가 SQL을 직접 작성하지 않고 프로그래밍 언어의 메서드를 통해 데이터를 조작할 수 있게 한다.

---

## N+1 문제란?

→ ORM 사용 시 발생하는 대표적인 성능 문제

- 현상 :  연관 관계가 설정된 엔티티를 조회할 때 최초 1회의 조회 쿼리(1)를 실행한 후, 조회된 데이터 개수(N)만큼 연관된 데이터를 얻기 위한 추가 쿼리(N)가 발생하는 현상
- 결과 : 의도치 않게 수많은 쿼리가 DB에 전송되어 성능 저하를 유발한다.

→ ORM은 기본적으로 데이터를 필요한 시점에 가져오는 지연 로딩 전략을 주로 사용한다.

- 발생 메커니즘
    1. Team 목록을 조회하는 쿼리 실행 (1번)
    2. 각 Team 객체를 순회하며 소속된 Member에 접근하려고 함.
    3. Member 정보가 아직 로딩되지 않아서 Member를 조회하는 쿼리가 별도로 발생 (N번)
- 해결 방법
    - Fetch Join : JPQL 등에서 join fetch 키워드를 사용하여 처음 쿼리를 날릴 때 연관된 데이터(Member)까지 한번에 조인해서 가져오게 한다. (즉시 로딩 효과)
    - Batch Size 설정 : IN 절을 사용하여 여러 개의 연관 데이터를 묶어서 한 번에 조회하도록 설정한다. (하나씩 N번 가져오는게 아님.)
    
    → 1:N관계(컬렉션 조회)에서는 Fetch Join과 페이징을 같이 쓰면 절대 안된다. DB의 모든 데이터를 메모리에 로딩해서 페이징하기 때문에 서버가 죽게 된다. (Out of Memory 문제)
    
    → 그래서 Fetch Join 대신 지연로딩 + Batch Size 옵션을 사용한다.
    
    → 이렇게 하면 IN 쿼리가 나가기 때문에 쿼리 수도 줄이고 페이징도 안전하게 처리할 수 있다.
    

---

### 따라서 DB 성능의 핵심은 optimizer와 인덱스에 달려 있다.

→ 결국 디스크 I/O(입출력)를 얼마나 줄이느냐가 관건

- 옵티마이저의 역할 : 쿼리 성능을 결정짓는 가장 중요한 요소
    - 옵티마이저는 통계 정보를 바탕으로 인덱스를 사용할지, 데이블 전체를 읽을지(Full Table Scan) 결정한다.
- 인덱스의 영향
    - 장점 : 데이터의 위치 정보를 별도로 저장하여 전체 데이터를 검색하지 않고도 빠르게 특정 행에 접근할 수 있게 한다. (Random I/O 수행)
    - 단점 : 데이터의 생성, 수정, 삭제 시 인덱스 데이터도 함께 갱신해야 하므로 쓰기 성능이 저하된다.
- 실행 계획 (Execution Plan) : 개발자는 EXPLAIN 명령어 등을 통해 옵티마이저가 선택한 경로를 확인해야 한다.
    - 인덱스를 타지 않고 풀 스캔을 하고 있다면 튜닝 대상이다.

---

## 인덱스 → 물리적인 저장 방식에 따라 크게 두 가지로 나뉜다.

- 클러스터형 인덱스
    - 정의 : 테이블당 하나만 존재한다. 보통 primary key가 이 역할을 한다.
    - 구조 : 인덱스의 잎 노드가 실제 데이터 페이지이다.
    - 특징 : pk로 검색하면 데이터를 바로 찾는다.
    - 비유하자면 책의 페이지 번호 그 자체
- 비클러스터형 인덱스 = 보조 인덱스
    - 정의 : pk 이외의 컬럼에 건 인덱스이다. 여러 개 만들 수 있다.
    - 구조 : 인덱스의 잎 노드에는 실제 데이터가 아니라 pk 값만 들어있다.
    - 과정 : 보조 인덱스 검색 → pk 값 획득 → 다시 클러스터형 인덱스 검색 → 실제 데이터 획득.
    - 비유하자면 책 뒤편의 색인 느낌

→ 보조 인덱스를 탄다고 무조건 빠른게 아니다. 보조 인덱스에서 pk를 찾고 다시 원본 데이터를 찾아가는 과정(랜덤 입출력)이 너무 많으면 옵티마이저는 인덱스를 포기하고 풀 스캔을 선택하기도 한다.

- 커버링 인덱스 = 실무 튜닝에서 많이 사용
    - 상황 : 쿼리에서 요구하는 모든 컬럼이 인덱스 안에 다 포함되어 있는 경우
    - 효과 : 실제 데이터 테이블(클러스터형 인덱스)까지 갈 필요 없이 인덱스만 읽고 끝난다. 따라서 속도가 굉장히 빠르다.

---

## ORM은 DB를 망치는가?

→ ORM 자체가 DB 성능을 망치는 것이 아니라 ORM의 동작 원리를 이해하지 못하고 사용할 때 성능 문제가 발생한다.

- ORM의 한계
    - 복잡한 통계 쿼리나 대용량 배치 처리에서는 자동 생성된 SQL이 비효율적일 수 있다.
    - 추상화되어 있어 내부에서 어떤 쿼리가 나가는지 개발자가 인지하지 못할 위험이 있다.
- 올바른 사용은?
    - 단순 CRUD(생성, 조회, 수정, 삭제)는 ORM을 사용하여 생산성을 높인다.
    - 복잡한 쿼리나 성능이 중요한 지점에서는 직접 SQL을 작성하여 튜닝한다.
    - 항상 쿼리 로그를 모니터링하여 의도하지 않는 쿼리(N+1 등)가 발생하는지 확인해야 한다.