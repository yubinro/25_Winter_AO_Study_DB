# 4주차 — 트랜잭션 & 동시성 (서버 관점)

**핵심 질문**

- 여러 서버가 동시에 접근하면 무슨 일이 생기나?

**내용**

- Transaction 이란 ?
- Isolation 과 Isolation Level
- 서버 레벨 동시성 vs DB 레벨 동시성
- 왜 Serializable을 안 쓰는가

**키워드**

`ACID`, `Isolation`, `Lock`

---

# 1. 트랜잭션

- Transaction(트랜잭션) : DBMS에서 데이터를 다루는 논리적인 작업의 단위
- DB에서 데이터를 다룰 때 장애가 일어난 경우 데이터를 복구하는 작업의 단위가 된다.
- DB에서 여러 작업이 동시에 같은 데이터를 다룰 때 이 작업을 서로 분리하는 단위가 된다.
- 트랜잭션은 전체가 수행되거나 또는 전혀 수행되지 않아야 한다. (ALL or Nothing)

---

데이터베이스에 삽입, 수정, 삭제 등의 작업을 할 때 여러 개의 작업들을 하나의 트랜잭션으로 묶는다. 즉, 트랜잭션은 데이터를 다루는 논리적인 작업의 단위인것.

ex) A계좌에서 B계좌로 돈을 이체하는 경우에 이 업무는 A에서 돈을 빼는 것, B에게 돈을 더하는 것 → 2가지의 Update문으로 나뉘게 됨. 이것들은 개별적으로 수행되는 것이 아니라 하나의 트랜잭션으로 묶이게 되며 하나의 트랜잭션이 실행될 때 이 2개의 SQL문이 연속적으로 실행됨. 따라서 2개의 Update문이 하나의 트랜잭션으로 묶여있다고 가정할 때 1개의 SQL만 실행되는 상황은 발생하지 않음 → 이를 ALL or Nothing이라 함.

---

# 2. 트랜잭션 수행 과정

1. A계좌의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
2. B계좌의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어온다.
3. A 계좌에서 10000원을 인출한 값을 저장한다.
4. B 계좌에서 10000원을 입금한 값을 저장한다.
5. A 계좌의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.
6. B 계좌의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록한다.

트랜잭션의 수행 과정은 2가지 방법으로 나뉜다.

- 4번까지 수행한 후 commit을 하는 것 (방법1)
- 6번까지 종료한 수 commit을 하는 것 (방법2)

여기서 commit이란 트랜잭션의 수행이 완료됨을 트랜잭션 관리자에게 알려 주는 연산이다.

→ DBMS는 사용자에게 빠른 응답을 위해 방법1을 택한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image.png)

---

# 3. 트랜잭션의 ACID 성질

데이터베이스는 일반적인 프로그램과 다르게 4가지의 성질을 지닌다.→ ACID 성질

- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
    - ALL or Nothing의 성질으로 트랜잭션이 원자처럼 더 이상 쪼개지지 않는 하나의 프로그램 단위로 동작해야 한다는 의미이다.
    - 트랜잭션이 중간에 끊기면 이후에 해당 트랜잭션의 어디서부터 이어 수행되어야 하는지 모르기 때문에 원자성이라는 성질을 지니게 되었다.
- 일관성(Consistency) : 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
    - ex) 어떤 테이블의 기본키와 같은 속성은 유지되어야 한다는 것
    - ex) A에서 B로 돈 이체를 할 때 A와 B계좌의 돈의 총합은 같아야한다는 것
- 고립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
    - 데이터베이스는 클라이언트들이 같은 데이터를 공유하는 것이 목적이므로 여러 트랜잭션이 동시에 수행되어야 한다.
    - 이때 트랜잭션은 상호 간의 존재를 모르고 독립적으로 수행되어야 한다는 것이 고립성이다.
    - 고립성 = 격리성 라고 하기도 한다.
    - 고립성을 유지하기 위해서는 여러 트랜잭션이 동시에 접근하는 데이터에 대한 제어가 필요하다.
- 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.
    - 즉, 트랜잭션의 성공 결과 값은 장애발행 후에도 변함없이 보관되어야 한다는 것이다.
    - 트랜잭션이 정상적으로 완료(commit)된 경우에는 버퍼의 내용을 하드디스크(데이터베이스)에 확실히 기록하여야 하며, 부분 완료(Partial commit)된 경우에는 작업을 취소하여야 한다.
    - 따라서 정상적으로 완료 혹은 부분완료된 데이터는 DBMS가 책임지고 데이터베이스에 기록하는 성질이 지속성이다. (영속성이라고 표현하기도 한다.)

---

# 4. 트랜잭션과 DBMS

- DBMS는 원자성을 유지하기 위해 회복(복구)관리자 프로그램을 작동시킨다.
- DBMS는 일관성을 유지하기 위해 동시성 제어 알고리즘과 무결성 제약조건을 활용한다.
- DBMS는 고립성을 유지하기 위해 동시성 제어 알고리즘을 작동시킨다.
- DBMS는 지속성을 유지하기 위해 회복 관리자 프로그램을 이용함.

ex) 어떤 트랜잭션이 실행되다가 장애에 의해 부분 완료되는 상황 

→ 원자성과 지속성이라는 속성에 위배된다.

- 그래서 DBMS는 이를 유지하기 위해 회복 관리자 프로그램을 이용한다.
    - 회복 관리자 프로그램 : 일부만 진행된 트랜잭션을 취소시켜 원자성을 유지할 뿐 아니라 값을 트랜잭션 이전의 상태로 복원시켜 지속성을 유지시켜준다.

→ 일관성과 고립성을 유지하기 위해서는 값에 동시에 접근하지 않도록 동시성 제어(Locking)를 활용하여 이를 해결한다.

- 파일 시스템과 같은 경우처럼 값이 덮어 씌워지는(오버라이트) 경우

→ 일관성과 고립성에 위배되는 경우이다.

→ Locking을 하여 이를 만족시킨다.

→ DBMS는 잘목된 값에 대한 입력이 오면 일관성이 무너질 수 있으므로 이를 유지시키기 위해 무결성 제약조건도 활용한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%201.png)

---

## [기타 개념]

- 롤백(Rollback) : 트랜잭션이 행한 모든 연산을 취소시키거나 트랜잭션을 재시작한다.
- 롤백 연산은 트랜잭션의 실행 중에 장애가 발생한 경우에 수행된다. 장애가 발생한 경우는 데이터베이스에 일부만 반영되어 일관되지 못한 상태를 가질 수 있으므로 모두 취소하거나 트랜잭션을 재시작해야 한다.
- 트랜잭션은 활동(Active), 부분완료(Partially Committed), 완료(Committed), 실패(Failed), 철회(Aborted)의 5가지 상태를 가지게 된다.
- 활동
    - 트랜잭션이 Begin_transaction으로부터 실행을 시작하였거나 실행 중인 상태를 의미한다.
- 부분완료
    - 마지막 명령문을 실행시킨 직후의 상태를 의미하며 실패 또는 완료의 상태로 전이하게 되는 것을 의미한다.
- 실패
    - 트랜잭션의 실행 중에 장애나 오류가 발생하여 정상적인 실행을 더 이상 할 수 없는 상태이며 롤백 연산을 수행한 상태인 철회 상태로 전이하게 되는 것을 의미한다.
- 롤백에 의해 트랜잭션이 재시작되거나 강제종료되는 경우
    - 철회의 원인에 따라 처리가 달라짐
        1. 트랜잭션 자체의 논리적 오류가 아닌 경우
            - 재시작된다.
        2. 트랜잭션 내부의 논리적 오류여서 오류를 수정해야 하는 상황 or 얻고자 하는 데이터가 데이터베이스에 존재하지 않을 경우
            - 강제 종료된다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%202.png)

---

# 5. 동시성 제어(Currency Control)

- 다중 사용자 환경에서 둘 이상의 트랜잭션이 동시에 수행될 때, 일광선을 해치지 않도록 트랜잭션의 데이터을 접근 제어하는 것이다.
- 다중 사용자 환경을 지원하는 DBMS의 경우, 반드시 지원해야 하는 기능이다.

고립성 → 상호 간의 트랜잭션을 독립적으로 만들어준다.

그렇다면 2개 이상의 트랜잭션이 하나의 값에 접근하는 경우에는 어떻게 해야 될까?

- 2개의 트랜잭션이 모두 읽는 경우에는 문제가 발생하지 않지만
- 1개의 트랜잭션은 쓰고 1개의 트랜잭션은 읽는 경우에
    - 상황에 따라 오손 읽기, 반복불가능 읽기, 유령데이터 읽기 문제가 발생할 수 있다.
- 2개의 트랜잭션이 모두 쓰기 시
    - 무제어 명행 수행을 하는 경우에
        - 갱신 손실, 모순성, 연쇄 복귀 등의 문제가 발생할 수 있다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%203.png)

---

# 6. 갱신 손실(Lost Update)

- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것을 의미한다.
- 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생한다.
- 데이터베이스에서 절대 발생하면 안되는 현상이다.

즉, 갱신 손실이란 하나의 값에 계속해서 덮어쓰기(오버라이트)하여 데이터의 갱신이 무효화되는 현상이다.

ex) 초기값 X = 1000이 있고, 

트랜잭션 T1은 X += 300, 

트랜잭션 T2는 X -= 500 이라 할 때, 

- 동시성 제어를 해주지 않으면 1000이라는 값이 T1에 의해 1300이 된 상태에서
- T2가 아직 1300으로 Write 되기 전인 X = 1000을 Read하여 1300-500이 아니라 1000-500이 수행되어 500을 갖게 되었고
- T1과 T2가 순차적으로 값을 저장하여 덮어씌워지는 값의 손실을 갱신손실이라 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%204.png)

---

# 7. 모순성(Inconsistency)

- 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황이다.

ex) 초기값 X=1500, Y=1000이 있고, 

트랜잭션 T1은 X와 Y를 300 증가, 

트랜잭션 T2는 X와 Y를 3배씩 증가시킨다고 한다면

- 트랜잭션 T1이 수행될 때 X와 Y는 각각 1500과 1000이 읽혀야 합니다.
- T1이 수행되면서 X만을 1800으로 증가시키고 Write된 다음에 Y를 수행하는 것이 아닌 트랜잭션 T2가 수행된다고 한다면
- T2에 의해 X와 Y는 각각 5400과 3000이 되고 다시 T1의 Y가 Read를 해야하는 상황에서 1000이 아니라 3000이 읽히게 된다.
- 이렇게 어떤 값은 갱신 전의 값을, 다른 값은 갱신 후의 값을 읽어 데이터가 불일치하는 것을 모순성이라 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%205.png)

---

# 8. 연쇄 복귀(Cascading Rollback)

- 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생한다.
- 한 트랜잭션이 데이터를 갱신한 다음 실패하여 롤백 연산을 수행하는 과정에서 갱신과 롤백 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제이다.

ex) 초기값 X=1500, Y=1000과 

X를 300 증가시키고 Y를 200 감소시키는 트랜잭션 T1과 

X항목을 3배 증가시키는 트랜잭션 T2가 있다고 한다면 

- T1이 X를 300 증가시키고 Write 하여 1800이 된 상황에서 T2 트랜잭션이 실행되어 X를 3배하여 Write한 후 종료되었다고 가정한다.
- 그리고 T1이 이제 롤백 연산을 하여 X를 1500으로 다시 돌려놓으려고 하는데 T2는 이미 해당 트랜잭션을 완료하여 종료되었으므로 롤백할 수가 없게 되버리는 문제가 발생한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%206.png)

---

# 9. 락(Lock)

- 로킹(Locking)기법: 트랜잭션들이 동일한 데이터 항목에 대해 임의적인 병행 접근을 하지 못하도록 제어하는 것이다.
- 트랜잭션 T가 데이터 항목 X에 대해 Read(X) or Write(X)연산을 수행하려면 반드시 lock(X) 연산을 해주어야 한다.
- 트랜잭션 T가 실행한 lock(X)에 대해서는 해당 트랜잭션이 종료되기 전에 반드시 unlock(x)연산을 해주어야 한다.
- 트랜잭션 T는 다른 트랜잭션에 의해 이미 lock이 걸려 있는 X에 대해 다시 lock(X)를 수행시키지 못한다.
- 트랜잭션 T가 X에 lock을 걸지 않았다면, unlock(X)를 수행시키지 못한다.

즉, 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구가 바로 Lock이다. 

- 락은 트랜잭션이 읽기를 할 때 사용하는 공유락(LS, Shared Lock)과 읽고 쓰기를 할 때 사용하는 배타락(LX, Exclusive Lock)으로 나뉜다.
- 트랜잭션 T가 데이터 항목 X에 대하여 공유락을 설정할 경우, 트랜잭션 T는 해당 데이터 항목에 대해서 읽을 수 있지만 기록할 수 없다. 그리고 Read는 서로 영향을 주지 않으므로 다른 트랜잭션도 공유락이 설정된 X에 대해서 공유락을 동시에 설정할 수 있다.
- 트랜잭션 T가 데이터 항목 X에 대하여 배타락을 설정할 경우, 트랜잭션 T는 해당 데이터 항목에 대해서 읽을 수도 있고, 기록할 수도 있다. Write는 영향을 주는 작업이므로 다른 트랜잭션은 배타락을 설정한 데이터 항목 X에 대해서 어떠한 lock도 설정할 수 없다.

### [ 공유락과 베타락을 사용하는 규칙]

- 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
- 트랜잭션이 데이터 X를 읽기만 할 경우 LS(X)를 요청하고, 읽거나 쓸 경우 LX(X)를 요청한다.
- 다른 트랜잭션이 데이터에 LS(X)를 걸어둔 경우, LS(X)의요청은 허용하고 LX(X)는 허용하지 않는다.
- 다른 트랜잭션이 데이터에 LX(X)를 걸어둔 경우, LS(X)와 LX(X) 모두 허용하지 않는다.
- 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

### [2단계 락킹]

- 락킹 단위: 락킹 기법에서 사용하는 lock 연산의 대상이다.
- 2단계 락킹 규약: 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있어서 락킹 단계를 2개로 구분하여 이를 방지하는 방법이다.
- 확장 단계(Growing Phase): 트랜잭션은 새로운 lock 연산만 할 수 있고, unlock 연산은 할 수 없는 단계이다.
- 축소 단계(Shrinking Phase): 트랜잭션은 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계이다.
1. 락킹단위가 속성->튜플->릴레이션->데이터베이스로 커질수록 구현이 용이하고 락의 수가 적어지며 제어가 간단하지만 병행성이 떨어지는 반면 
2. 락킹단위가 작을수록 구현이 복잡하고 락의 수가 많고 제어 기법이 복잡하여도 병행성을 높일 수 있다. 
- 2단계 락킹 규약(2PLP: Two-Phase Locking Protocol)은 트랜잭션들이 lock하는 시간과 unlock을 하는 시간을 구분하여 수행하도록 하는 것이다.
- 2단계 락킹 규약을 사용하지 않으면 아래의 그림과 같이 일관성이 위배되는 문제가 발생할 수 있다.
    - 그래서 임의의 시간에 lock 또는 unlock을 하는 것이 아니라 확장 단계와 축소 단계를 두어 이를 해결해준다.
    - 2PLP는 직렬 가능성을 보장할 수 있는 규약으로 가장 많이 사용되지만 교착상태(데드락, Deadlock)에 빠질 수 있으므로 이를 해결해주어야 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%207.png)

### [ 데드락(Deadlock)]

- 데드락(Deadlock): 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는 현상이다.
- 데드락은 교착상태라고도 한다.

데이터베이스의 데드락과 운영체제의 데드락은 상당히 비슷하다. 

- 위의 정의를 풀어 설명하면 공통된 자원을 이용하기 위해 여러 개의 트랜잭션이 서로 lock을 걸어주다가 무한 대기 상태에 빠지는 것을 데드락이라 한다.

ex) 먼저 T1에서 A에 대해 락을 걸고 T2에서 B에 대해 락을 걸었다고 했을 때

- 그다음에 T1에서 B에 대해 락을 걸고 T2가 A에 대해 락을 건다면
    - T1과 T2는 서로 A, B에 대한 락을 유지하며 무한루프에 빠지게 된다.
    - 일반적으로 데드락이 발생하면 DBMS가 T1 혹은 T2 중 하나를 강제로 중지시켜 한 트랜잭션은 정상적으로 실행되며 중지된 트랜잭션에서 변경한 데이터는 원래 상태로 되돌려 놓는다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%208.png)

---

# 10. 트랜잭션 고립 수준

### [ 오손읽기(Dirty Read) ]

- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 발생하는 문제이다.
- 작업중인 트랜잭션 2가 작업을 롤백한 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출한다.

아래의 그림과 같이 T1이 T2가 롤백 되기 전의 데이터를 읽었고, T2가 롤백이 되면 T1이 의미가 없는 값을 갖게 되므로 문제가 발생한다. 

그리고 이러한 무효가 된 데이터를 읽게되어 발생하는 문제를 오손읽기(Dirty Read)라고 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%209.png)

### [ 반복불가능 읽기(Non-repeatable Read) ]

- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(Update) 트랜잭션 1이 다시 한번 데이터를 읽을 때 생기는 문제이다.
- 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과와 다른 결과가 나오는 현상이다.

아래의 그림과 같이 T1이 먼저 값을 읽었고 T2가 값을 갱신(Update)하였다고 했을 때 T1이 다시 값을 읽으려고 하면 바로 전에 읽은 값이 달라지는데 이를 반복불가능 읽기라고 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2010.png)

### [ 유령데이터 읽기(Phantom Read) ]

- 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(Insert) 트랜잭션 1이 다시 한번 데이터를 읽을 때 생기는 문제이다.
- 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상이다.

아래의 그림과 같이 T1이 먼저 값을 읽었고, T2가 값을 삽입(Insert)하였다고 했을 때 T1이 다시 값을 읽으려고 하면 바로 전에는 없었던 값이 읽히게 되는데 이를 유령데이터 읽기라고 한다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2011.png)

---

# 11. 트랜잭션 고립 수준 명령어(Transaction Isolation Level Instruction)

- DBMS에서 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하기 위해 제공하는 명령어이다.
- 트랜잭션이 작업을 수행하다 보면 위의 오손 읽기, 반복불가능 읽기, 유령데이터 읽기와 같은 문제를 직면할 수 있다.
    - 그래서 Lock보다는 완화된 방법으로 트랜잭션을 동시에 실행시키면서, 발생하는 문제를 해결하기 위해 DBMS가 제공하는 명령어가 바로 트랜잭션 고립 수준 명령어(Transaction Isolation Level Instruction)이다.
    - 여기에는 고립 수준을 나타내는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE과 같은 명령어들이 있다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2012.png)

### [ READ UNCOMMITTED ]

- 고립 수준이 Level 0으로 가장 낮은 명령어로, 자신의 데이터에 아무런 공유락을 걸지 않는다.

READ UNCOMMITTED는 자신의 데이터에 아무런 공유락도 걸지 않지만 배타락은 데이터의 갱신손실 문제 때문에 걸어주어야 한다. 

또한 다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽습니다. SELECT 문을 수행하는 경우 해당 데이터에 공유락이 걸리지 않는 Level입니다. 

따라서, 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안 다른 사용자는 B라는 아직 완료되지 않은 데이터(오손 데이터) B를 읽을 수 있다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2013.png)

### [ READ COMMITTED ]

- 고립 수준이 Level 1인 명령어로, 오손 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지 가능하다.

다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행된다. SQL Server가 Default로 사용하는 Isolation Level으로 SELECT 문이 수행되는 동안에 공유락이 걸리게됩니다. 

그러므로 어떤 사용자가 A라는 데이터를 B라는 데이터로 변경하는 동안에 다른 사용자는 해당 데이터에 접근할 수 없다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2014.png)

### [ REPEATABLE READ ]

- 고립 수준이 Level 2인 명령어로, 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료될 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(Update)할 수 없도록 한다.

다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행된다. 다른 고립화 수준에 비해 데이터의 동시성(Concurrency)이 낮아 특별하지 않은 상황이라면 사용하지 않는 것이 좋다. 

즉, 트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 공유락이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다. 

ex) SELECT number 

FROM A 

WHERE number BETWEEN 1 and 10 을 수행했을 때

이 범위에 해당하는 number가 2 or 3이 있는 경우 다른 사용자가 number가 2 or 3인 행에 대한 변경(UPDATE)이 불가능하지만 나머지 범위에 대해서 행을 삽입(INSERT)하는 것이 가능하다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2015.png)

### [ SERIALIZABLE ]

- 고립 수준이 Level 3으로 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.

데이터 집합에 범위를 지어 잠금을 설정할 수 있기 때문에 다른 사용자가 데이터를 변경(UPDATE) 또는 삽입(Insert)하려고 할 때 트랜잭션을 완벽하게 분리할 수 있다. 

이 명령어는 가장 제한이 심하고 동시성도 낮다. 

즉, SELECT 문이 사용하는 모든 데이터에 공유락이 걸리므로 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정(UPDATE) 및 입력(INSERT)이 불가능하다. 

앞의 Repeatable Read의 경우에는 1에서 10사이의 number에 대한 삽입이 가능하였지만 SERIALIZABLE은 SELECT의 대상이 되는 모든 테이블에 공유락을 설정하는 것과 같아서 나머지 범위에 대한 삽입(INSERT)이 불가능합니다.

![image.png](4%EC%A3%BC%EC%B0%A8%20%E2%80%94%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20&%20%EB%8F%99%EC%8B%9C%EC%84%B1%20(%EC%84%9C%EB%B2%84%20%EA%B4%80%EC%A0%90)/image%2016.png)

---

# 12. SERIALIZABLE을 사용하지 않는 이유

핵심 요약 → **SERIALIZABLE**은 데이터 무결성(안전함) 측면에서는 완벽하지만 

성능(속도)과 동시성 처리 능력은 부족하기 때문이다.

### 1. 치명적인 성능 저하 (Low Performance)

- 가능 큰 이유는 속도이다. 데이터베이스는 데이터를 정확하게 저장하는 것도 중요하지만 빠르게 처리하는 것도 매우 중요하다.
    - serializable은 조회(SELECT)만 해도 해당 데이터 범위에 공유 락을 걸어버린다.
    - 단순 조회만 하는데도 수정, 삭제, 삽입을 못하게 막기 때문에 사용하지 않는다.
- 처리량(Throughput) 급감
    - 동시 접속자 수가 적어도 서로 락을 걸고 해제하느라 대기 시간이 길어진다.
    - 따라서 초당 처리할 수 있는 트랜잭션수가 아주 낮아지기 때문에 사용하지 않는다.

### 2. 동시성 저하 (Poor Concurrency)

- 웹 서비스는 수천, 수만 명의 사용자가 동시에 접속한다. 하지만 serializable을 쓰면 멀티 태스킹이 불가능해진다.
- 줄 서기 현상이 발생하고 웹 서비스에 부적합하기 때문에 사용하지 않는다.
    - 웹 서비스는 멈추지 않고 돌아가는 것이 훨씬 중요하기 때문이다.

### 3. 데드락(Deadlock, 교착 상태) 발생 확률 급상승

- 락을 너무 빡빡하게 걸다보니 서로가 서로의 잠금이 풀리기 기다리는 상황이 빈번하게 발생한다.
    - 서로가 서로를 잠금한다면 DB가 강제로 트랜잭션 하나를 롤백해야하는데 이는 서비스 오류로 이어진다.

## [대안]

대부분의 서비스(네이버, 카카오, 배민 등)는 Read commit 혹은 Repeatable Read 수준을 사용한다.

- **낙관적 락 (Optimistic Lock) :** DB 레벨에서 락을 걸지 않고, 어플리케이션 코드에서 충돌을 감지하는 방식을 사용하여 성능과 정합성을 모두 잡는다.
- **MVCC (다중 버전 동시성 제어) :** 잠금을 걸지 않고, 데이터의 스냅샷(과거 버전)을 보여주는 방식으로 읽기/쓰기를 동시에 가능하게 만든다. (현대 DB의 핵심 기술)